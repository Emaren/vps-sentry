#!/usr/bin/env bash
set -euo pipefail

STATUS="/var/lib/vps-sentry/public/status.json"
[[ -f "$STATUS" ]] || exit 0

tmp="$(mktemp)"

# Format: "udp:68,tcp:22" (comma-separated). Whitespace ok.
expected="${VPS_SENTRY_EXPECTED_PUBLIC_PORTS:-}"
if [ -z "$expected" ] && [ -f /etc/systemd/system/vps-sentry.service.d/95-expected-ports.conf ]; then
  expected="$(sed -n 's/^Environment=VPS_SENTRY_EXPECTED_PUBLIC_PORTS=//p' /etc/systemd/system/vps-sentry.service.d/95-expected-ports.conf | tail -n1 | tr -d "\"'")"
fi
expected_ranges="${VPS_SENTRY_EXPECTED_PUBLIC_PORT_RANGES:-}"
if [ -z "$expected_ranges" ] && [ -f /etc/systemd/system/vps-sentry.service.d/95-expected-ports.conf ]; then
  expected_ranges="$(sed -n 's/^Environment=VPS_SENTRY_EXPECTED_PUBLIC_PORT_RANGES=//p' /etc/systemd/system/vps-sentry.service.d/95-expected-ports.conf | tail -n1 | tr -d "\"'")"
fi
# Format mirrors expected list. Built from explicit UFW "DENY IN" rules.
blocked=""

if command -v ufw >/dev/null 2>&1; then
  blocked="$(
    (ufw status 2>/dev/null || true) \
      | awk '
          {
            to = $1
            action = $2
            direction = $3
            gsub(/\(v6\)/, "", to)
            if (to ~ /^[0-9]+\/(tcp|udp)$/ && (action == "DENY" || action == "REJECT") && direction != "OUT") {
              split(to, parts, "/")
              if (length(parts) == 2) {
                printf "%s:%s\n", tolower(parts[2]), parts[1]
              }
            }
          }
        ' \
      | sort -u \
      | paste -sd, -
  )"
fi

jq --arg expected "$expected" --arg expected_ranges "$expected_ranges" --arg blocked "$blocked" '
  def splitcsv($s):
    if ($s|length)==0 then []
    else ($s | split(",")
      | map(gsub("^\\s+|\\s+$";""))
      | map(select(length>0)))
    end;

  def parse_rule($r):
    ($r | ascii_downcase | gsub("\\s+";"")) as $x
    | if ($x | test("^(tcp|udp):[0-9]+$")) then
        ($x | split(":")) as $p
        | { proto: $p[0], min: ($p[1]|tonumber), max: ($p[1]|tonumber) }
      elif ($x | test("^(tcp|udp):[0-9]+-[0-9]+$")) then
        ($x | split(":")) as $p
        | ($p[1] | split("-")) as $r
        | { proto: $p[0], min: ($r[0]|tonumber), max: ($r[1]|tonumber) }
      else
        null
      end;

  def any_rule_match($rules; $proto; $port):
    any($rules[]?; .proto == $proto and ($port >= .min and $port <= .max));

  (($expected | splitcsv(.)) + ($expected_ranges | splitcsv(.))) as $exp_raw
  | ($exp_raw | map(parse_rule(.)) | map(select(. != null))) as $exp_rules
  | ($blocked | splitcsv(.)) as $blk
  | (.ports_public // []) as $pp
  | ($pp | map(
      select(
        (.proto|tostring|ascii_downcase) as $proto
        | (.port|tonumber) as $port
        | (($proto + ":" + ($port|tostring)) as $k
          | ((any_rule_match($exp_rules; $proto; $port) | not) and ($blk | index($k) | not)))
      )
    )) as $unexpected
  | ($pp | map(
      select(
        ((.proto|tostring|ascii_downcase) + ":" + (.port|tostring)) as $k
        | ($blk | index($k))
      )
    )) as $blocked_public

  | .expected_public_ports = $exp_raw
  | .blocked_inbound_ports = $blk
  | .ports_public_blocked_inbound = $blocked_public
  | .blocked_public_ports_count = ($blocked_public | length)
  | .ports_public_unexpected = $unexpected
  | .unexpected_public_ports_count = ($unexpected | length)
' "$STATUS" > "$tmp"

# Preserve perms/ownership as best as we can (mv keeps dir perms; file is replaced)
cat "$tmp" > "$STATUS"
rm -f "$tmp"
